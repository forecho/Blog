<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Laravel | forecho 的独立博客]]></title>
  <link href="https://blog.forecho.com/categories/laravel/atom.xml" rel="self"/>
  <link href="https://blog.forecho.com/"/>
  <updated>2020-01-11T03:56:41+00:00</updated>
  <id>https://blog.forecho.com/</id>
  <author>
    <name><![CDATA[forecho]]></name>
    <email><![CDATA[caizhenghai@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Laravel 写单元测试]]></title>
    <link href="https://blog.forecho.com/laravel-tests.html"/>
    <updated>2019-01-14T07:03:58+00:00</updated>
    <id>https://blog.forecho.com/laravel-tests</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section" id="markdown-toc-section">引言</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">单元测试</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">基本的断言</a></li>
      <li><a href="#section-3" id="markdown-toc-section-3">断言返回数据数组包含某个键值</a></li>
      <li><a href="#section-4" id="markdown-toc-section-4">多组数据测试</a></li>
      <li><a href="#console-" id="markdown-toc-console-">Console 测试</a></li>
      <li><a href="#section-5" id="markdown-toc-section-5">断言类</a></li>
      <li><a href="#section-6" id="markdown-toc-section-6">异常测试</a></li>
      <li><a href="#section-7" id="markdown-toc-section-7">队列测试</a></li>
      <li><a href="#api-" id="markdown-toc-api-">API 接口测试</a></li>
      <li><a href="#section-8" id="markdown-toc-section-8">第三方接口依赖测试</a></li>
      <li><a href="#section-9" id="markdown-toc-section-9">关于清除测试数据</a></li>
      <li><a href="#section-10" id="markdown-toc-section-10">加速跑单元测试</a></li>
    </ul>
  </li>
  <li><a href="#section-11" id="markdown-toc-section-11">最后</a></li>
</ul>

<h2 id="section">引言</h2>

<p>新公司入职第一件事就是让我给一个用 Laravel 框架开发的项目写单元测试，我会说『当了这么多年的程序员没写过单元测试吗？』，于是我一边学习一边写，这篇文章是我写了一个月单元测试的经验分享。</p>

<h2 id="section-1">单元测试</h2>

<h3 id="section-2">基本的断言</h3>

<ul>
  <li>断言两边数据相等使用 <code>assertEquals($a, $a1)</code></li>
</ul>

<p><code>
public function testComputePermission()
{
    $totalPermission = TCH::computePermission([PointsAccountPermissions::TRANSFER]);
    $this-&gt;assertEquals($totalPermission, PointsAccountPermissions::TRANSFER);
}
</code></p>

<ul>
  <li>断言结果是 <code>true</code> 使用 <code>assertTrue($a)</code>，与之相反的是 <code>assertFalse($b)</code></li>
  <li>断言文件是否存在使用 <code>assertFileExists($path)</code></li>
  <li>断言数据库没有数据使用 <code>assertDatabaseMissing('user', [])</code></li>
  <li>断言两个类一样使用 <code>assertSame($a, $b)</code></li>
  <li>……</li>
</ul>

<!--more-->

<h3 id="section-3">断言返回数据数组包含某个键值</h3>

<p><code>php
/**
* @throws \App\Exceptions\ThirdPartyServiceErrorException
*/
public function testDecodeUnionId()
{
    $accountBaseService = app()-&gt;make(AccountBaseService::class);
    $unionId = mt_rand(1, 100);
    $response = $accountBaseService-&gt;decodeUnionId([$unionId]);
    $this-&gt;assertArrayHasKey('data', $response);
    $data = data_get($response, 'data.list.0');
    $this-&gt;assertArrayHasKey('brand_id', $data);
    $this-&gt;assertArrayHasKey('account_id', $data);
}
</code></p>

<h3 id="section-4">多组数据测试</h3>

<p>多组数据可以使用 <code>@dataProvider</code> 的方式传入数据来测试。比方说我测试一个金额，只支持正数、两位小数。</p>

<p>&#8220;`php
namespace App\Rules\Rules;</p>

<p>use App\Rules\AmountRule;
use PHPUnit\Framework\TestCase;</p>

<p>class AmountRuleTest extends TestCase
{
    /**
     * @var AmountRule()
     */
    protected $rule;</p>

<pre><code>public function setUp()
{
    parent::setUp();
    $this-&gt;rule = new AmountRule();
}

/**
 *
 * @dataProvider evenPassData
 * @param int|float $int
 * @return void
 */
public function testEvenPass($int)
{
    $this-&gt;assertTrue($this-&gt;rule-&gt;passes('test', $int));
}

/**
 *
 * @dataProvider evenFailData
 * @param int|float $int
 * @return void
 */
public function testEvenFail($int)
{
    $this-&gt;assertFalse($this-&gt;rule-&gt;passes('test', $int));
}

public function evenPassData()
{
    return [
        [100],
        [100.11],
        [2],
        [2.00],
        [2.01],
        [2.1],
    ];
}

public function evenFailData()
{
    return [
        [-1],
        [1.111],
        [-1.1],
        [0],
    ];
} } ```
</code></pre>

<h3 id="console-">Console 测试</h3>

<p>&#8220;`php
namespace App\Console\Commands;</p>

<p>use App\Models\ClientApp;
use Illuminate\Console\Command;
use Webpatser\Uuid\Uuid;</p>

<p>class CreateClient extends Command
{
    //  something code</p>

<pre><code>/**
 * Execute the console command.
 *
 * @return mixed
 * @throws \Exception
 */
public function handle()
{
    $title = $this-&gt;ask('客户端应用名称');
    $desc = $this-&gt;ask('客户端应用描述');
    $access = $this-&gt;ask('access (1: 私有  2: 内部　３:　公开)');

    $appId = Uuid::generate();
    $secret = str_random(64);

    $data = [
        // something code
    ];

    ClientApp::create($data);

    $this-&gt;info("Done!\n");
    $this-&gt;info('client_id: ' . $appId);
    $this-&gt;info('secret: ' . $secret);
} }
</code></pre>

<p>&#8220;`</p>

<p>&#8220;`php
public function testCreateClient()
{
    $application = new Application();</p>

<pre><code>$testedCommand = $this-&gt;app-&gt;make(CreateClient::class);
$testedCommand-&gt;setLaravel(app());
$application-&gt;add($testedCommand);

$commandTester = new CommandTester($testedCommand);
$commandTester-&gt;setInputs(['测试', '单元测试', 1]);
$commandTester-&gt;execute(['command' =&gt; $testedCommand-&gt;getName()]);

$this-&gt;assertRegExp('/client_id: \w{8}(-\w{4}){3}-\w{12}\\n/', $commandTester-&gt;getDisplay());
$this-&gt;assertDatabaseHas(ClientApp::TABLE_NAME, [
    'title' =&gt; '测试',
    'description' =&gt; '单元测试',
    'access' =&gt; 1,
]); } ```
</code></pre>

<h3 id="section-5">断言类</h3>

<p><code>php
/**
* @test
*/
public function getAccountByUnionId()
{
    $service = new PointsAccountService();
    $record = $service-&gt;getAccountByUnionId(1);
    $this-&gt;assertInstanceOf(PointsAccount::class, $record);
}
</code></p>

<blockquote>
  <p>PS: 方法含有 test 或者使用注释 <code>@test</code> 都可以识别是单元测试的一个方法。</p>
</blockquote>

<h3 id="section-6">异常测试</h3>

<p>默认没有测试异常的方法，所以我们自己实现一个。</p>

<p>&#8220;`php
/**
* Asserts that the given callback throws the given exception.
*
* @param string $expectClass The name of the expected exception class
* @param callable $callback A callback which should throw the exception
*/
protected function assertException(string $expectClass, callable $callback)
{
    try {
        $callback();
    } catch (\Throwable $exception) {
        $this-&gt;assertInstanceOf($expectClass, $exception, ‘An invalid exception was thrown’);
        return;
    }</p>

<pre><code>$this-&gt;fail('No exception was thrown'); } ```
</code></pre>

<p><code>php
public function testSomeException()
{
    $service = new PointsAccountService();
    $this-&gt;assertException(\InvalidArgumentException::class, function () use ($service) {
        $service-&gt;getAccountByUnionId(0);
    });
}
</code></p>

<h3 id="section-7">队列测试</h3>

<p>&#8220;`php
use Illuminate\Support\Facades\Queue;</p>

<p>public function testJob()
{
    Queue::fake();</p>

<pre><code>// 推送数据到队列
SomeJob::dispatch($vars);

// 断言已经在队列中
Queue::assertPushed(SomeJob::class); } ```
</code></pre>

<p>需要补充的是队列这块注意 <code>phpunit.xml</code> 文件里面的 <code>&lt;env name="QUEUE_CONNECTION" value="sync"/&gt;</code> 代码，意思是使用同步的方式跑队列。这里要根据自己的情况修改配置。</p>

<h3 id="api-">API 接口测试</h3>

<p><code>php
use Illuminate\Http\Request;
public function testUserCreate()
{
    $data = [
        'username' =&gt; 'test',
    ];
    $response = $this-&gt;json(Request::METHOD_POST, config('app.url') . '/users', $data);
    $response-&gt;assertStatus(200)
        -&gt;assertJson([
            'code' =&gt; 0,
        ]);
    // something other assert
}
</code></p>

<h3 id="section-8">第三方接口依赖测试</h3>

<p>如果我们项目中有依赖第三方接口，我们测试的时候不会直接去请求第三方接口，而是断言其接口成功返回。那么具体怎么测试呢？使用 mock 是一种方式，但是我使用的是另外一种方式：</p>

<ul>
  <li>添加接口返回的数据，比方说添加 <code>tests/fixtures/simple_data/vendor/v1/member/info.json</code> 文件，里面就贴上接口正常返回的数据。</li>
  <li>添加控制器方法 <code>app/Http/Controllers/TestController.php</code> 文件，里面的方法做文件映射：</li>
</ul>

<p>&#8220;`php
namespace App\Http\Controllers;</p>

<p>use Illuminate\Http\Response;
use Illuminate\Routing\Route;</p>

<p>class TestController extends Controller
{
    public function index(Route $route): Response
    {
        if ($url = str_replace(‘api/tests/v1’, ‘’, $route-&gt;uri)) {
            $path = base_path(‘/tests/fixtures/simple_data/vendor/v1’);
            $data = file_get_contents(“{$path}{$url}.json”);
            return response($data, 200, [‘Content-Type’ =&gt; ‘application/json’]);
        }
        return response(‘’);
    }
}
&#8220;`</p>

<ul>
  <li>添加路由配置文件 <code>routes/api.php</code></li>
</ul>

<p><code>php
// tests v1 版本 account-base-service 和 notification
Route::group(['prefix' =&gt; 'tests/v1',], function () {
    Route::get('member/info', 'TestController@index');
    Route::post('member/create', 'TestController@index');
    // ……
});
</code></p>

<blockquote>
  <p>PS: 这里最后两步之所以不使用路由回调函数方式实现，是因为 <code>php artisan route:cache</code> 命令不支持路由 <code>Closure</code></p>
</blockquote>

<h3 id="section-9">关于清除测试数据</h3>

<p>Laravel 自带一个 <code>RefreshDatabase</code> trait，如果你的测试类加入了 <code>use RefreshDatabase;</code> 代码，那么每跑一个测试会清除数据。但是我嫌这样跑测试太慢，基本上都不用这个方法。</p>

<p>Laravel 默认如果有 <code>.env.testing</code> 环境配置文件的话，跑单元测试会使用这个文件的配置，里面可以配置单独的数据库等其他配置。所以我目前本地使用的是这种方式来跑单元测试。</p>

<h3 id="section-10">加速跑单元测试</h3>

<p>跑单元测试我们一般用下面这个命令跑：</p>

<p><code>sh
vendor/bin/phpunit
</code></p>

<p>但是单元测试多了之后，上面这种方式跑单元测试会变慢，我们可以用 <a href="https://github.com/krakjoe/phpdbg">phpdbg</a> 来加速跑运行单元测试，以节省时间。</p>

<p>安装：</p>

<p><code>
sudo apt-get install php7.2-phpdbg -y
</code></p>

<p>使用：</p>

<p><code>
phpdbg -qrr ./vendor/bin/phpunit -dmemory_limit=1024M  
</code></p>

<p>如果还是嫌慢，还有优化空间，以后再补充。</p>

<h2 id="section-11">最后</h2>

<p>我们的单元测试只在本地和 <a href="https://travis-ci.org/">travis</a> 里面跑，自从写了单元测试之后，改代码要放心的很多。如果时间允许的话，推荐大家也多写写单元测试。养成好习惯。</p>
]]></content>
  </entry>
  
</feed>
