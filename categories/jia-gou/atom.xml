<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 架构 | forecho 的独立博客]]></title>
  <link href="https://blog.forecho.com/categories/jia-gou/atom.xml" rel="self"/>
  <link href="https://blog.forecho.com/"/>
  <updated>2020-01-11T03:56:41+00:00</updated>
  <id>https://blog.forecho.com/</id>
  <author>
    <name><![CDATA[forecho]]></name>
    <email><![CDATA[caizhenghai@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用 Docker 搭建 EFK]]></title>
    <link href="https://blog.forecho.com/use-efk.html"/>
    <updated>2019-03-14T13:58:22+00:00</updated>
    <id>https://blog.forecho.com/use-efk</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#efk" id="markdown-toc-efk">什么是 EFK？</a></li>
  <li><a href="#section" id="markdown-toc-section">安装</a></li>
  <li><a href="#section-1" id="markdown-toc-section-1">测试</a>    <ul>
      <li><a href="#section-2" id="markdown-toc-section-2">本机测试</a></li>
      <li><a href="#docker-" id="markdown-toc-docker-">docker 测试</a></li>
    </ul>
  </li>
  <li><a href="#fluentd--tag" id="markdown-toc-fluentd--tag">为 Fluentd 配置动态 tag</a></li>
  <li><a href="#store-data-in-elasticsearch" id="markdown-toc-store-data-in-elasticsearch">Store data in Elasticsearch</a>    <ul>
      <li><a href="#section-3" id="markdown-toc-section-3">最后</a></li>
    </ul>
  </li>
</ul>

<h2 id="efk">什么是 EFK？</h2>

<p>EFK 分别指 Elasticsearch + Fluentd + Kibana，一般用来做日志系统的。他们的作用分别是：</p>

<ul>
  <li>Elasticsearch：分布式搜索引擎。具有高可伸缩、高可靠、易管理等特点。可以用于全文检索、结构化检索和分析，并能将这三者结合起来。Elasticsearch 基于 Lucene 开发，现在使用最广的开源搜索引擎之一，Wikipedia 、StackOverflow、Github 等都基于它来构建自己的搜索引擎。</li>
  <li>Fluentd：一个消息采集，转化，转发工具，目的是提供中心化的日志服务。</li>
  <li>Kibana：可视化化平台。它能够搜索、展示存储在 Elasticsearch 中索引数据。使用它可以很方便的用图表、表格、地图展示和分析数据。</li>
</ul>

<!--more-->

<p>随着公司的项目、集群越来越多，统一的日志管理系统是必不可少的。</p>

<p>下面我就分享一下我今天搭建的过程和踩过的坑。</p>

<h2 id="section">安装</h2>

<p>自从用过 Docker 之后，只要能用 Docker 的我都用 Docker，能省不少精力和时间，那么安装 EFK 也少，我第一想到的就是去 Google 搜索『Docker efk』，然后找到这个项目 <a href="https://github.com/alextanhongpin/docker-efk">alextanhongpin/docker-efk</a>，按着下面的命令执行就能安装成功：</p>

<p><code>sh
git clone https://github.com/alextanhongpin/docker-efk.git
cd docker-efk
docker-compose up -d elasticsearch fluentd kibana
</code></p>

<p>以上三条命令就搭建成功了，方不方便？另外我还想说：</p>

<ul>
  <li>查看这个项目的 <code>docker-compose.yml</code> 文件，你会发现还有 portainer、dejavu、web 三个服务，用不上其实可以不必安装。如果你想全部安装的话，最后一步就使用 <code>docker-compose up -d</code> 命令。</li>
  <li>如果安装发现有提示端口被占用的情况，你可以改 <code>docker-compose.yml</code> 文件之后再运行启动命令就可以了。比方说 web 服务的 80 端口被占用，那么你可以改为 <code>127.0.0.1:8888:80</code>，这样本地访问 http://127.0.0.1:8888/ 就可以了。</li>
</ul>

<h2 id="section-1">测试</h2>

<h3 id="section-2">本机测试</h3>

<ul>
  <li>可以使用 docker 安装一个 Ubuntu 环境测试，命令如下：</li>
</ul>

<p><code>
docker run --rm --log-driver=fluentd ubuntu /bin/echo 'Hello world'
</code></p>

<ul>
  <li>还可以写使用 Python 脚本测试：</li>
</ul>

<p><code>
pip install pyfluent
vim test-efk.py
</code></p>

<p>写入代码：</p>

<p><code>python
# !/usr/bin/env python
# -*- coding: utf-8 -*-
from pyfluent.client import FluentSender
fluent = FluentSender() # 默认使用 location 和 24224 端口连接 fluentd
fluent.send('Hello pyfluent!')
</code></p>

<p>然后运行</p>

<p><code>
python test-efk.py
</code></p>

<h3 id="docker-">docker 测试</h3>

<p>现在的场景是另一个项目在本机的另一个 Docker （下文称 a-docker）里面请求 Fluentd 写入日志，今天这个问题搞了半天都没写入，发现 fluentd 一直是没接收到，也就是说 a-docker 一直没连接到 efk-docker，也就是说：</p>

<ul>
  <li>a-docker 里面不能 curl 到 127.0.0.1:24224，所以要用宿主主机的 ip</li>
  <li>通过 <code>docker ps</code> 查看 docker-efk_fluentd 的容器只监听了 127.0.0.1 ip 的 24224 端口号，其他 ip 不管。</li>
</ul>

<p><strong>所以我们可以简单粗暴的这样解决：</strong></p>

<ul>
  <li>获取本机的 ip 地址</li>
  <li>修改 a-docker 里面的项目连接 fluentd host 值为本机的 ip</li>
  <li>修改 efk-docker 的 <code>docker-compose.yml</code> 文件，把 fluentd 服务的 ports 改为</li>
</ul>

<p><code>
ports:
    - 0.0.0.0:24224:24224
    - 0.0.0.0:24224:24224/udp
</code></p>

<p><strong>更好的解决方案：</strong></p>

<p>待补充……</p>

<h2 id="fluentd--tag">为 Fluentd 配置动态 tag</h2>

<p>项目之间的日志如何区分？当然是修改 <code>fluentd.conf</code> 配置文件的 <code>logstash_prefix</code> 来区分，除了为每一个项目手动添加一个 store 配置项的笨方式外，我们还可以通过动态的方式来实现动态标签功能，我修改之后的配置文件如下：</p>

<p>&#8220;`</p>
<source />

<p>@type forward
  port  24224
  bind 0.0.0.0
&lt;/source&gt;</p>

<p>&lt;filter <strong>.</strong>&gt;
  @type record_transformer
  enable_ruby</p>
<record>
    tag ${tag}
  </record>
<p>&lt;/filter&gt;</p>

<h1 id="store-data-in-elasticsearch">Store data in Elasticsearch</h1>
<p>&lt;match *.**&gt;
  @type copy</p>
<store>
    @type elasticsearch_dynamic
    host docker.for.mac.localhost
    port 9200
    # type_name fluentd
    logstash_format true
    logstash_prefix ${record[&#8220;tag&#8221;]}
    # logstash_prefix fluentd
    # include_tag_key true
    include_tag_key false
    type_name access_log
    tag_key @log_name
  </store>
<store>
    @type stdout
  </store>
<p>&lt;/match&gt;
&#8220;`</p>

<h2 id="section-3">最后</h2>

<p>总结一下本篇文章，主要介绍：</p>

<ul>
  <li>EFK 是指 Elasticsearch + Fluentd + Kibana ，一个非常强大统一管理日志的解决方案。</li>
  <li>EFK 使用 Docker 的搭建过程，以及我踩过的坑和解决方案。</li>
  <li>EFK 动态 tag 的配置方式。</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[大型网站架构的演化]]></title>
    <link href="https://blog.forecho.com/da-xing-wang-zhan-jia-gou-de-yan-hua.html"/>
    <updated>2013-10-14T22:58:00+00:00</updated>
    <id>https://blog.forecho.com/da-xing-wang-zhan-jia-gou-de-yan-hua</id>
    <content type="html"><![CDATA[<p>网站一般分三个部分：应用程序、文件、数据库。</p>

<ol>
  <li>初级阶段的网站架构就是把所有的资源放在一台服务器上就够了。</li>
  <li>应用服务和数据服务分离：整个网站使用三台服务器 - 应用服务器、文件服务器、数据库服务器。</li>
  <li>使用缓存改善网站性能：一种是本地缓存，更好的是远程分布式缓存。（本地缓存虽然速度更快，但是受应用服务器内存的限制，其缓存数据量有限，而且会出现和应用服务器争用内存的情况）</li>
  <li>使用应用服务器集群改善网站的并发处理能力，通过负载均衡调度服务器。</li>
  <li>数据库读写分离：通过配置两台数据库主从关系，实现主数据库同步更新从数据库，读数据库的时候通过从数据库获取到数据。</li>
  <li>使用反向代理和CDN加速网站响应：CDN部署在网络供应商的机房里，可以从距离最近的网络提供商机房获取数据。反向代理部署在网站的中心机房，访问机房的时候，如果反向代理服务器中缓存着用户请求的资源，就将其直接返回给用户。</li>
  <li>使用分布式文件系统和分布式数据库系统。</li>
  <li>使用NoSQL和搜索引擎。</li>
  <li>业务拆分：将一个网站拆分成许多不同的应用，每个应用独立部署。（通常还是访问同一个数据库）</li>
  <li>分布式服务：把每一个应用系统相同的业务提取出来，独立部署。可复用的业务链接数据库，提供公用业务服务，而应用系统只需要管理用户界面，通过分布式服务调用共用业务服务完成具体业务操作。</li>
</ol>

<p>–The End–</p>
]]></content>
  </entry>
  
</feed>
